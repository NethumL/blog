[{"categories":null,"content":"Hi! I’m Nethum Lamahewage. I’m primarily a programmer - mainly as a hobby since about mid-2019, and now also as a student. As of 2022, I’m a Computer Science \u0026 Engineering undergraduate at the University of Moratuwa. ","date":"April 21, 2022","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Online Presence My main “official” online presences are currently limited to the following. ","date":"April 21, 2022","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"GitHub This is where some of my “important” projects are hosted. The majority of them are private for various reasons, but a few are public, including the source for this website. The ones that are private are that way usually because I don’t consider them particularly useful for most people. The list of private repositories includes my dotfiles repo. If you’re not familiar with what they are, here is a nice introduction. It has my dotfiles dating back to the beginning of 2021. I’m pretty sure that that’s not when I started properly using dotfiles, but that’s as far back as my commit history goes. In the future, I may open it up, but for now, I’m planning on making at least a few posts about individual components of it here. ","date":"April 21, 2022","objectID":"/about/:1:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"LinkedIn This is my other official presence online. It exists mainly for career purposes (it’s LinkedIn). You can expect it to be reasonably up to date, at least with the more important details. ","date":"April 21, 2022","objectID":"/about/:1:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Medium I originally joined Medium for the purpose of having an online blog. Since I set up this site, I won’t be using Medium that often. All of my posts will be here on this site, but a few of them will occasionally be posted there as well. ","date":"April 21, 2022","objectID":"/about/:1:3","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"About this site This is a Hugo-generated static site using Org Mode, ox-hugo, and the LoveIt theme, hosted on GitHub Pages. I will likely be doing a separate post about how this is set up and the process I went through to get to this site, and if/when I do, I’ll link it here. ","date":"April 21, 2022","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["programming"],"content":"Introduction I was working on a project using PyQt5 when I found myself in need of spellchecking in a QTextEdit widget. I tried to find a reasonable implementation of it, but I didn’t find one. Maybe it exists somewhere out there, but, it was an interesting little side project, so I decided to try making it myself. If you just want the code, you can get it from the GitHub repository. If you are interested in an explanation of the code, read on. First, a little introduction to what will be used for this. ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:1:0","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"PyQt5 This is a set of Python bindings for the cross-platform Qt framework. There is another set of bindings called PySide2. I won’t go into the differences between them here, but all of the code here should work fine with PySide2 as well, with only the relevant import statements needing to be changed. You can install it using pip install PyQt5. ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:1:1","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"enchant This is a spellchecking library written in C and C++. There are other spellchecking libraries of course, but I chose this as it seemed to work better than the others I tried. If you want to use a different library for the spellchecking, you can do that by simple replacing the implementation of the wrapper in the next section. You can install the library from the GitHub repository, and you can install the Python bindings using pip install pyenchant. ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:1:2","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Wrapping enchant While this part isn’t necessary, I initially did this in case I needed to change the library doing the spellchecking without needing to change the rest of the code. This wrapper will provide an “interface” to get a list of suggestions given a word, add a word to the personal word list, and to check a particular word’s spelling. The code itself should be pretty self-explanatory, but I have added some comments as additional explanation. from typing import Callable from enchant import DictWithPWL from PyQt5.QtCore import QTemporaryFile class SpellCheckWrapper: def __init__( self, personal_word_list: list[str], addToDictionary: Callable[[str], None] ): # Here, we take a function: addToDictionary(str) # That's what we call when adding a new word to the personal word list # The reason we take this from outside is that this way, when using this class, # we can store the permanent personal word list however we like, and this class doesn't need to care # Creating temporary file for enchant to store the personal word list temporarily self.file = QTemporaryFile() self.file.open() self.dictionary = DictWithPWL( \"en_US\", self.file.fileName(), ) self.addToDictionary = addToDictionary self.word_list = set(personal_word_list) self.load_words() def load_words(self): for word in self.word_list: self.dictionary.add(word) def suggestions(self, word: str) -\u003e list[str]: return self.dictionary.suggest(word) def correction(self, word: str) -\u003e str: # Get the best match return self.dictionary.suggest(word)[0] def add(self, new_word: str) -\u003e bool: if self.check(new_word): return False self.word_list.add(new_word) self.addToDictionary(new_word) self.dictionary.add(new_word) return True def check(self, word: str) -\u003e bool: return self.dictionary.check(word) def getNewWords(self) -\u003e set[str]: return self.word_list ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:2:0","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Custom QSyntaxHighlighter Qt conveniently has a QSyntaxHighlighter (docs) class which we can use to show any words that are misspelled. Here, we will subclass it to use a SpellCheckWrapper instance to check the spellings of all the words, and show the usual red line under any misspelled words. import re from PyQt5.QtCore import Qt from PyQt5.QtGui import QSyntaxHighlighter, QTextCharFormat from spellcheckwrapper import SpellCheckWrapper class SpellCheckHighlighter(QSyntaxHighlighter): # Matches strings of length 2 or more wordRegEx = re.compile(r\"\\b([A-Za-z]{2,})\\b\") def highlightBlock(self, text: str) -\u003e None: if not hasattr(self, \"speller\"): return # Formatting for misspelled words self.misspelledFormat = QTextCharFormat() self.misspelledFormat.setUnderlineStyle(QTextCharFormat.SpellCheckUnderline) # Platform and theme dependent self.misspelledFormat.setUnderlineColor(Qt.red) for word_object in self.wordRegEx.finditer(text): if not self.speller.check(word_object.group()): self.setFormat( word_object.start(), word_object.end() - word_object.start(), self.misspelledFormat, ) def setSpeller(self, speller: SpellCheckWrapper): self.speller = speller ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:3:0","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Correction action Now we need to create a simple QAction (docs) that will fire a custom signal when clicked, and pass its text as an argument. We will be using this to create the list of suggested words in the context menu. from PyQt5.QtCore import pyqtSignal from PyQt5.QtWidgets import QAction class SpecialAction(QAction): actionTriggered = pyqtSignal(str) def __init__(self, *args): super().__init__(*args) self.triggered.connect(self.emitTriggered) def emitTriggered(self): self.actionTriggered.emit(self.text()) ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:4:0","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Subclassing QTextEdit Now we come to the main part of this article. I will break down this class into a few sections. The first one is for the imports and the constructor. Each one after that will be for the other methods in the class. ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:0","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Imports and constructor This part should be self-explanatory. from PyQt5.QtCore import QEvent, Qt, pyqtSlot from PyQt5.QtGui import QContextMenuEvent, QMouseEvent, QTextCursor from PyQt5.QtWidgets import QMenu, QTextEdit # Importing the classes we wrote in the previous sections from correction_action import SpecialAction from highlighter import SpellCheckHighlighter from spellcheckwrapper import SpellCheckWrapper class SpellTextEdit(QTextEdit): def __init__(self, *args): if args and type(args[0]) == SpellCheckWrapper: super().__init__(*args[1:]) self.speller = args[0] else: super().__init__(*args) self.highlighter = SpellCheckHighlighter(self.document()) if hasattr(self, \"speller\"): self.highlighter.setSpeller(self.speller) ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:1","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Set speller def setSpeller(self, speller): self.speller = speller self.highlighter.setSpeller(self.speller) ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:2","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Mouse press event This is a little hack to make it so that right-clicking will move the text cursor to the mouse position. If the mouse press event is a right click, then we change that into a left click. def mousePressEvent(self, event: QMouseEvent) -\u003e None: if event.button() == Qt.RightButton: event = QMouseEvent( QEvent.MouseButtonPress, event.pos(), Qt.LeftButton, Qt.LeftButton, Qt.NoModifier, ) super().mousePressEvent(event) ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:3","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Context menu event Here, we need to build the context menu. First, we can use the built-in createStandardContextMenu method to make the basics. Then, we add on the list of suggestions, and a button to add to dictionary. createSuggestionsMenu is explained in the next section. def contextMenuEvent(self, event: QContextMenuEvent) -\u003e None: self.contextMenu = self.createStandardContextMenu(event.pos()) # Select and retrieve the word under the cursor textCursor = self.textCursor() textCursor.select(QTextCursor.WordUnderCursor) self.setTextCursor(textCursor) wordToCheck = textCursor.selectedText() if wordToCheck != \"\": suggestions = self.speller.suggestions(wordToCheck) if len(suggestions) \u003e 0: self.contextMenu.addSeparator() self.contextMenu.addMenu(self.createSuggestionsMenu(suggestions)) if not self.speller.check(wordToCheck): # This action will add the selected word to the personal word list addToDictionary_action = SpecialAction( \"Add to dictionary\", self.contextMenu ) addToDictionary_action.triggered.connect(self.addToDictionary) self.contextMenu.addAction(addToDictionary_action) self.contextMenu.exec_(event.globalPos()) ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:4","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Create suggestions menu We create the suggestions menu from the given list of suggestions. Here, we use that SpecialAction from before. When one is clicked, the correctWord method is called. def createSuggestionsMenu(self, suggestions: list[str]): suggestionsMenu = QMenu(\"Change to\", self) for word in suggestions: action = SpecialAction(word, self.contextMenu) action.actionTriggered.connect(self.correctWord) suggestionsMenu.addAction(action) return suggestionsMenu ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:5","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Replace the selected word with the given correction @pyqtSlot(str) def correctWord(self, word: str): textCursor = self.textCursor() textCursor.beginEditBlock() textCursor.removeSelectedText() textCursor.insertText(word) textCursor.endEditBlock() ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:6","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Add to dictionary This adds the selected word to the dictionary. @pyqtSlot() def addToDictionary(self): textCursor = self.textCursor() new_word = textCursor.selectedText() self.speller.add(new_word) self.highlighter.rehighlight() ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:5:7","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["programming"],"content":"Conclusion There you have it. If you want to try it out, I have included a small example application in the GitHub repository. There are of course some improvements to be made. For example, with the current implementation, if a user selects some text and right-clicks, the selection will change to the word under the pointer. As I wrote this code for use in another project of mine, this basic functionality was enough. ","date":"April 16, 2022","objectID":"/posts/2022/04/pyqt-spellcheck/:6:0","tags":["python","pyqt"],"title":"Integrating spellchecking into a PyQt5 QTextEdit widget with enchant","uri":"/posts/2022/04/pyqt-spellcheck/"},{"categories":["configuration"],"content":"Introduction I’ve been using macOS for a little over a year now. Before that, I had only ever known Windows. I have used Ubuntu a bit, but that barely counts. Once I moved to macOS, it took quite some time to get used to it. I do still occasionally boot into Windows, using Bootcamp, but it’s only when I need to use some software that doesn’t run on macOS. At first, I used macOS much like I used to use Windows. However, since I am doing a CS degree, I needed to get familiar with programming related tools, and that is how I found Vim. I found it interesting and gave it a go. I won’t go into what that was like here, as there are many people on the internet who have told their stories of learning Vim. Eventually, I gained an interest in configuring my system to suit me better, and I came across Hammerspoon. ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:1:0","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Hammerspoon ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:2:0","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"About Simply put, it is a automation tool running on Lua. It has numerous APIs for macOS functionality, and with it, you can control pretty much whatever you want to. Basically, you’re only limited by your imagination (and your skill at writing the relevant code). ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:2:1","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Installing Using either Homebrew or from the website ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:2:2","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Configuring Setup Create ~/.hammerspoon/init.lua This is the starting point of your config. You can split your config into separate files (and you should, if you do any serious configuring), and then use the require function to import them The following are a couple of basic examples of what you can do with Hammerspoon Reload config You can replace the modifier combination with a hyper key if you want hs.hotkey.bind({\"cmd\", \"alt\", \"ctrl\"}, \"h\", function() hs.reload() hs.console.clearConsole() end) Wi-Fi watcher local wifiwatcher = hs.wifi.watcher.new(function() local net = hs.wifi.currentNetwork() if net == nil then hs.notify.show(\"You lost Wi-Fi connection\", \"\", \"\", \"\") else hs.notify.show(\"Connected to Wi-Fi network\", \"\", net, \"\") end end) wifiwatcher:start() ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:2:3","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"More You can go to Hammerspoon’s Getting started guide to see some more examples. And if you want to know more about any part of the API, you will find that it is very well documented. You can also find ‘Spoons’, which are basically plugins which provide additional functionality, at this link. And you can find many resources out there about setting up various things using Hammerspoon. Now let’s jump into the RecursiveBinder Spoon ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:2:4","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"RecursiveBinder Spoon ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:3:0","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"About When I first started configuring Hammerspoon, I setup a hyper key, and added a few keybindings. But I soon hit a roadblock where I was using up all the keys (or at least the most easily accessible ones) It wasn’t that long since I had been introduced to Vim, and I was getting comfortable with the leader key system. It turned out that there was a Spoon for Hammerspoon called RecursiveBinder that could do the same thing. ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:3:1","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Installing Download from here Copy into ~/.hammerspoon/Spoons Your ~/.hammerspoon directory should now look something like this: . ├── Spoons │ └── RecursiveBinder.spoon │ ├── docs.json │ └── init.lua └── init.lua ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:3:2","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Configuring singleKey This is a convenience function used to easily create a table representing a keybinding with no modifiers, and also automatically translate capital letters to normal letters with shift modifier For example, singleKey('o', 'open') returns {{}, 'o', 'open'}, and singleKey('O', 'open') returns {{'shift'}, 'o', 'open'} Simple keymap and binding hs.loadSpoon(\"RecursiveBinder\") spoon.RecursiveBinder.escapeKey = {{}, 'escape'} -- Press escape to abort local singleKey = spoon.RecursiveBinder.singleKey local keyMap = { [singleKey('b', 'browser')] = function() hs.application.launchOrFocus(\"Firefox\") end, [singleKey('t', 'terminal')] = function() hs.application.launchOrFocus(\"Terminal\") end, [singleKey('d', 'domain+')] = { [singleKey('g', 'github')] = function() hs.urlevent.openURL(\"github.com\") end, [singleKey('y', 'youtube')] = function() hs.urlevent.openURL(\"youtube.com\") end } } hs.hotkey.bind({'option'}, 'space', spoon.RecursiveBinder.recursiveBind(keyMap)) Explanation First load the spoon using hs.loadSpoon RecursiveBinder.escapeKey is the keybinding used to abort The next line is just for convenience, so that I can use singleKey without having to type out spoon.RecursiveBinder.singleKey every time Next, I create a table of keybindings. The first two are to open the browser and the terminal respectively, and next set is a nested group. Pressing option+space will trigger RecursiveBinder. Helper text will popup at the bottom of your screen with the browser, terminal, and domain+ key bindings. Pressing b or t will call the functions provided, and open Firefox and Terminal respectively (and also dismiss the helper text) Pressing d will enter the next layer, and the helper will change to show the g and y key bindings, and pressing one of those will call the corresponding functions, and open GitHub and YouTube respectively (in your default browser) Styling Some simple styling spoon.RecursiveBinder.helperFormat = { atScreenEdge = 2, -- Bottom edge (default value) textStyle = { -- An hs.styledtext object font = { name = \"Fira Code\", size = 18 } } } Refer to the hs.alert.defaultStyle documentation for general styling, and hs.styledtext for text styling ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:3:3","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Leader key ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:4:0","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Loading from config.json To make later configuration easier, I set it up so that it loads as much of the config as possible from an easily editable JSON file The config.json file is in the private folder, which is where personal aspects of the config are stored. This way, you can separate those from the main configuration, if you were to upload your Hammerspoon config somewhere local config = hs.json.read(\"private/config.json\") This is what that config.json file looks like: { \"applications\": [ { \"bundleID\": \"org.mozilla.firefox\", \"key\": \"b\", \"name\": \"Firefox\" }, { \"bundleID\": \"com.microsoft.VSCode\", \"key\": \"c\", \"name\": \"VSCode\" } ], \"domains\": [ { \"key\": \"g\", \"name\": \"GitHub\", \"url\": \"github.com\" }, { \"key\": \"y\", \"name\": \"YouTube\", \"url\": \"youtube.com\" } ], \"notes\": { \"rootPath\": \"/Users/your_username_here/notes_html/\", \"contents\": [ { \"folder\": \"programming\", \"key\": \"p\", \"name\": \"Programming\", \"contents\": [ { \"file\": \"python\", \"key\": \"p\", \"name\": \"Python\" }, { \"file\": \"js\", \"key\": \"j\", \"name\": \"JavaScript\" } ] }, { \"file\": \"general\", \"key\": \"g\", \"name\": \"General\" } ] } } Using YAML instead of JSON If your config.json is getting too big, it might be a good idea to convert it into a different file type, such as YAML (as it is easier to read/write). I’ll leave that as an exercise for the reader (partly because I haven’t done that yet either, though I do intend to). As a starting point, you may want to look into this. ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:4:1","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Applications \u0026 Domains key map Here, I’m iterating through the list of applications in my config, and adding them to the keymap one by one. For this, I can use a function in Hammerspoon called hs.fnutils.each. It takes in a table and a function, which will be called for each element in the table For each application, I’m assigning the corresponding key and a function that will launch it using Hammerspoon’s hs.application.launchOrFocusByBundleID If you want to find the bundleid of an application the following AppleScript will return it: id of app 'Firefox' (just replace Firefox with the application name, as it appears in your Applications folder). You can also run this in a shell like this: osascript -e \"id of app 'Firefox'\" The following lua code will add the applications to a key map local applicationsKeyMap = {} hs.fnutils.each(config.applications, function(app) applicationsKeyMap[singleKey(app.key, app.name)] = function() hs.application.launchOrFocusByBundleID(app.bundleID) end end) As another example, here is how I’m loading the domains key map local domainsKeyMap = {} hs.fnutils.each(config.domains, function(domain) domainsKeyMap[singleKey(domain.key, domain.name)] = function() hs.urlevent.openURL(\"https://\" .. domain.url) end end) ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:4:2","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Notes key map If you looked at the config above, you may have noticed the notes section. I also set up a keymap to open those notes in the browser. I think the format of the config is self explanatory, so I’ll go ahead with the actual lua code local function generate(data, path) local folder = {} hs.fnutils.each(data, function(elem) if elem['contents'] ~= nil then -- Sub-folder folder[singleKey(elem.key, elem.folder .. '+')] = generate(elem.contents, path .. elem.folder .. '/') else -- File folder[singleKey(elem.key, elem.name)] = function() hs.urlevent.openURL(\"file://\" .. path .. elem.file .. \".html\") end end end) return folder end local notesKeyMap = generate(config.notes.contents, config.notes.rootPath) This one is more complicated, but I’m including it to show you just how much you can achieve with this. I’ll go through it part by part. Explanation All of my notes are in a folder called notes_html in my $HOME folder (aka ~/), and I’ve categorised some into sub-folders. For example, there is a sub-folder named programming, with separate notes for each programming language. generate is a recursive function that is called on the notes section of the config It iterates over the list provided, and for each element, it does one of two things. If it is a sub-folder (a simple way to check this is to check for the contents attribute), then it calls the function again for that folder’s list of entries(files or folders), and assigns it to the corresponding key in the keymap If it is a file, then it just assigns the corresponding key in the keymap and attaches the function to open the note For any programmers reading, the idea is similar to a depth first search of a tree To open the note, I’m using the hs.urlevent.openURL function. They are all html files, so they are automatically opened in my default browser While recursively going through the notes, I’m also passing along the current path when calling the function and in the case of a sub-folder appending it to the end of the path Now to use this, you don’t really need to understand all of this. Just set all of it in the config.json, making sure to set the correct config.notes.rootPath as well. ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:4:3","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Putting it all together All that remains is to put it all together, like so local keyMap = { [singleKey('o', 'open+')] = applicationsKeyMap, [singleKey('d', 'domain+')] = domainsKeyMap, [singleKey('n', 'note+')] = notesKeyMap, [singleKey('h', 'hammerspoon+')] = { [singleKey('r', 'reload')] = function() hs.reload() hs.console.clearConsole() end, [singleKey('c', 'config')] = function() hs.execute(\"/usr/local/bin/code ~/.hammerspoon\") end } } hs.hotkey.bind({'option'}, 'space', spoon.RecursiveBinder.recursiveBind(keyMap)) Here, I’ve also included a couple of keybindings for Hammerspoon. One to reload the config, and the other to open the config in VSCode ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:4:4","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Bonus ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:5:0","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Sorted helper text If you used this, you may have noticed that the order of the keys in the helper text is not consistent. To fix this, I added some more code to sort the helper text before showing. The following code is to be added to RecursiveBinder.spoon/init.lua Not much needs to change. A function called compareLetters is added, and the beginning of the for loop(in showHelper), and the part just before it are changed as shown -- Function to compare two letters -- It sorts according to the ASCII code, and for letters, it will be alphabetical -- However, for capital letters (65-90), I'm adding 32.5 (this came from 97 - 65 + 0.5, where 97 is a and 65 is A) to the ASCII code before comparing -- This way, each capital letter comes after the corresponding simple letter but before letters that come after it in the alphabetical order local function compareLetters(a, b) asciiA = string.byte(a) asciiB = string.byte(b) if asciiA \u003e= 65 and asciiA \u003c= 90 then asciiA = asciiA + 32.5 end if asciiB \u003e= 65 and asciiB \u003c= 90 then asciiB = asciiB + 32.5 end return asciiA \u003c asciiB end -- Here I am adding a bit of code to sort before showing -- Only the part between START and END changes local function showHelper(keyFuncNameTable) local helper = '' local separator = '' local lastLine = '' local count = 0 -- START local sortedKeyFuncNameTable = {} for keyName, funcName in pairs(keyFuncNameTable) do table.insert(sortedKeyFuncNameTable, {keyName = keyName, funcName = funcName}) end table.sort(sortedKeyFuncNameTable, function(a, b) return compareLetters(a.keyName, b.keyName) end) for _, value in ipairs(sortedKeyFuncNameTable) do local keyName = value.keyName local funcName = value.funcName -- END count = count + 1 local newEntry = keyName .. ' -\u003e ' .. funcName -- make sure each entry is of the same length if string.len(newEntry) \u003e obj.helperEntryLengthInChar then newEntry = string.sub(newEntry, 1, obj.helperEntryLengthInChar - 2) .. '..' elseif string.len(newEntry) \u003c obj.helperEntryLengthInChar then newEntry = newEntry .. string.rep(' ', obj.helperEntryLengthInChar - string.len(newEntry)) end -- create new line for every helperEntryEachLine entries if count % (obj.helperEntryEachLine + 1) == 0 then separator = '\\n' elseif count == 1 then separator = ' ' else separator = ' ' end helper = helper .. separator .. newEntry end helper = string.match(helper, '[^\\n].+$') previousHelperID = hs.alert.show(helper, obj.helperFormat, true) end To cleanly integrate this into RecursiveBinder, much more changes are required, but for now, this works for me. ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:5:1","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"},{"categories":["configuration"],"content":"Conclusion OK, time for some closing words. I have been using Hammerspoon for about a year and a half, and so far, I am beyond impressed. The power it brings is frankly amazing, and there is so much you can do with it. Like I said in the beginning, you are only limited by your imagination. ","date":"April 15, 2022","objectID":"/posts/2022/04/hammerspoon-global-leader-key/:6:0","tags":["dotfiles","hammerspoon"],"title":"Setting up a global leader key for macOS with Hammerspoon","uri":"/posts/2022/04/hammerspoon-global-leader-key/"}]